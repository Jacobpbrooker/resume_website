<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Simple Queue Algorithm in C | Jacob Brooker - Project Showcase</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Simple Queue Algorithm in C" />
<meta name="author" content="Jacob Brooker" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A queue created in C is a form of abstract data type that can be created using a linked list format. The signature property of the queue created by me is that data structures can only be added or deleted from the head or tail of the queue. Inserting into the queue is not allowed. This gives the big O notation of O(1) for inserting and deleting, with a linear search notation of O(n)." />
<meta property="og:description" content="A queue created in C is a form of abstract data type that can be created using a linked list format. The signature property of the queue created by me is that data structures can only be added or deleted from the head or tail of the queue. Inserting into the queue is not allowed. This gives the big O notation of O(1) for inserting and deleting, with a linear search notation of O(n)." />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2021/10/04/simple-queue-algorithm.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2021/10/04/simple-queue-algorithm.html" />
<meta property="og:site_name" content="Jacob Brooker - Project Showcase" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-10-04T15:43:03-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Simple Queue Algorithm in C" />
<script type="application/ld+json">
{"headline":"Simple Queue Algorithm in C","dateModified":"2021-10-04T15:43:03-04:00","datePublished":"2021-10-04T15:43:03-04:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2021/10/04/simple-queue-algorithm.html"},"author":{"@type":"Person","name":"Jacob Brooker"},"description":"A queue created in C is a form of abstract data type that can be created using a linked list format. The signature property of the queue created by me is that data structures can only be added or deleted from the head or tail of the queue. Inserting into the queue is not allowed. This gives the big O notation of O(1) for inserting and deleting, with a linear search notation of O(n).","url":"http://localhost:4000/jekyll/update/2021/10/04/simple-queue-algorithm.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Jacob Brooker - Project Showcase" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Jacob Brooker - Project Showcase</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/resume/">Resume</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Simple Queue Algorithm in C</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-10-04T15:43:03-04:00" itemprop="datePublished">Oct 4, 2021
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Jacob Brooker</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>A queue created in C is a form of abstract data type that can be created using a linked list format. The signature property of the queue created by me is that data structures can only be added or deleted from the head or tail of the queue. Inserting into the queue is not allowed. This gives the big O notation of O(1) for inserting and deleting, with a linear search notation of O(n).</p>

<h3>Application Decomposition and Explanation</h3>

<p>The appplication uses three structs as part of the data storage. The first is a simple patient struct that contains the age and ID number. The next struct makes the individual node of the queue. Each of these nodes contains a single patient, and a pointer to the next node in the queue. The final struct used in the application stores the head and tail of the queue. This allows for forward and reverse traversal of the queue.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">patient</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">patientNumber</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">}</span><span class="n">PATIENT</span><span class="p">,</span> <span class="o">*</span> <span class="n">PPATIENT</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="nc">patient</span><span class="o">*</span> <span class="n">patientData</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">node</span><span class="o">*</span> <span class="n">pNext</span><span class="p">;</span>
<span class="p">}</span><span class="n">NODE</span><span class="p">,</span> <span class="o">*</span> <span class="n">PNODE</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="nc">node</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">node</span><span class="o">*</span> <span class="n">tail</span><span class="p">;</span>
<span class="p">}</span><span class="n">QUEUE</span><span class="p">,</span> <span class="o">*</span> <span class="n">PQUEUE</span><span class="p">;</span>
</code></pre></div></div>

<p>First, I needed to create a patient. I used a random number generator to assign a number. To store the patient information inside the patient struct, I allocated memory, and then filled that memory with the randomly generated number. I used the generated patient and created a node.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PPATIENT</span> <span class="nf">createPatient</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">PPATIENT</span> <span class="n">patient</span><span class="p">;</span>                                       <span class="c1">// create pointer to patient </span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">patient</span> <span class="o">=</span> <span class="p">(</span><span class="n">PPATIENT</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PATIENT</span><span class="p">))))</span>	    <span class="c1">// malloc the size of patient at the pointer to patient</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to allocate memory for patient - Now Exiting</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">patient</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">99</span><span class="p">;</span>		                        <span class="c1">// assign random age 0 - 99 to patient</span>
	<span class="n">patient</span><span class="o">-&gt;</span><span class="n">patientNumber</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">RAND_MAX</span> <span class="o">+</span> <span class="mi">10000</span><span class="p">)</span>	<span class="c1">// assign random 9 digit patient ID</span>
		<span class="o">*</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">5000</span> <span class="o">+</span> <span class="mi">10000</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">patient</span><span class="p">;</span>											<span class="c1">// return the pointer to patient</span>
<span class="p">}</span>

<span class="n">PNODE</span> <span class="nf">createPatientNode</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">PNODE</span> <span class="n">node</span><span class="p">;</span>	<span class="c1">// create node pointer</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">PNODE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">NODE</span><span class="p">))))</span><span class="c1">// malloc the size of node at the pointer to node location</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to allocate memory for queue - Now Exiting</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">NODE</span><span class="p">));</span>	<span class="c1">// set the malloc(ed?) memory to '\0'</span>

	<span class="n">node</span><span class="o">-&gt;</span><span class="n">patientData</span> <span class="o">=</span> <span class="n">createPatient</span><span class="p">();</span>	<span class="c1">// create/assign patient to node</span>
	<span class="c1">// node-&gt;pNext intentially left unassigned to be assigned in enqueue function</span>
	<span class="k">return</span> <span class="n">node</span><span class="p">;</span>				<span class="c1">// return the new patient node with created patient</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Next I needed to create a function that would enqueue the newly created node, successfully pushing the nodes in a singly linked list.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">PQUEUE</span> <span class="n">queue</span><span class="p">,</span> <span class="n">PNODE</span> <span class="n">node</span><span class="p">)</span>  
<span class="p">{</span>
	<span class="kt">bool</span> <span class="n">returnBool</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>	<span class="c1">// set return bool</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>		<span class="c1">// if the head of the queue is null set the head to this node</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>		<span class="c1">// then set the tail to the same location in the queue</span>
		<span class="n">returnBool</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>		<span class="c1">// set the return bool to true</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>	<span class="c1">// if there is a head in the queue we set the queue tail next to the node</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>			<span class="c1">// set the queue tail to the node</span>
		<span class="n">returnBool</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>			<span class="c1">// set the return bool to true</span>
	<span class="p">}</span>

	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// set the queue tail pNext to NULL with each interation  	</span>

	<span class="k">return</span> <span class="n">returnBool</span><span class="p">;</span>			<span class="c1">// return bool</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Next, we are going to look at the traversal functions. To move through the queue, I chose to use a recursive function that looked through the queue front to back, and had a seperate recursive function that moved back to front.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">PQUEUE</span> <span class="n">queue</span><span class="p">)</span>									<span class="c1">// pass the queue to a traversal function</span>
<span class="p">{</span>
	<span class="n">recursiveTraverse</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>							<span class="c1">// head of queue is passed to regular traversal (front to back)</span>
<span class="p">}</span>

<span class="n">PNODE</span> <span class="nf">recursiveTraverse</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">patientNode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">simpleDisplayPatient</span><span class="p">(</span><span class="n">patientNode</span><span class="o">-&gt;</span><span class="n">patientData</span><span class="p">);</span>			<span class="c1">// display patient information to terminal</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">patientNode</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>							<span class="c1">// check if pNext is NULL (this will be the final item in queue)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">patientNode</span><span class="p">;</span>									<span class="c1">// if it is the final item, return and begin unwinding recursive function</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">recursiveTraverse</span><span class="p">(</span><span class="n">patientNode</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">);</span>				<span class="c1">// if it is not the last node in the list, pass the next node into function and repeat</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reverseTraverse</span><span class="p">(</span><span class="n">PQUEUE</span> <span class="n">queue</span><span class="p">)</span>							<span class="c1">// pass the queue to a reverse traversal function</span>
<span class="p">{</span>
	<span class="n">reverseRecursiveTraverse</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>					<span class="c1">// tail of queue is passed to reverse traversal function (back to front)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reverseRecursiveTraverse</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">patientNode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">simpleDisplayPatient</span><span class="p">(</span><span class="n">patientNode</span><span class="o">-&gt;</span><span class="n">patientData</span><span class="p">);</span>			<span class="c1">// display patient information to terminal</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">patientNode</span><span class="o">-&gt;</span><span class="n">pPrevious</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>														<span class="c1">// check if pPrevious is NULL (this will be the first item in queue)</span>
		<span class="k">return</span> <span class="n">patientNode</span><span class="p">;</span>
	<span class="p">}</span>														<span class="c1">// if it is the first item, return and begin unwinding recursive function</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">reverseRecursiveTraverse</span><span class="p">(</span><span class="n">patientNode</span><span class="o">-&gt;</span><span class="n">pPrevious</span><span class="p">);</span>	<span class="c1">// if it is not the first node in the list, pass the previous node into function and repeat</span>
	<span class="p">}</span>														
<span class="p">}</span>
</code></pre></div></div>

<p>The final function created for this application is a dequeue function. This takes the patient at the head of the queue (singly linked list) and pops the node off.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">dequeue</span><span class="p">(</span><span class="n">PQUEUE</span> <span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">simpleDisplayPatient</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">patientData</span><span class="p">);</span>			<span class="c1">// dispay the patient</span>
	
	<span class="n">QUEUE</span> <span class="n">tempQUEUE</span><span class="p">;</span>										<span class="c1">// create a temporary copy of the queue</span>

	<span class="n">tempQUEUE</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>					<span class="c1">// assign the head of temporary queue to the pNext of queue head</span>
	<span class="n">freeNode</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>									<span class="c1">// free the node</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">tempQUEUE</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>							<span class="c1">// set the head of the queue to the head of the temporary queue</span>
<span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h3>Running the Application</h3>
<p>The main function of the application accepts a command line argument for the number of patients that will be created by the system. In this example, I instructed the application to create 5 patients, enqueue these nodes, traverse the code forwards and backwards, and then dequeue these patient nodes to end the program.</p>

<p><img src="/assets/img/programs/queue.png" height="500px" />
<br /><br /></p>
<hr />

<h3><a href="https://github.com/Jacobpbrooker/simple_queue">You can find the GitHub Repo here!</a></h3>
<p><br />
If you have any questions at all, please do not hesitate to reach out. Thanks for reading!</p>

  </div><a class="u-url" href="/jekyll/update/2021/10/04/simple-queue-algorithm.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Jacob Brooker - Project Showcase</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Jacob Brooker</li><li><a class="u-email" href="mailto:jacobpbrooker@gmail.com">jacobpbrooker@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Jacobpbrooker"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Jacobpbrooker</span></a></li><li><a href="https://www.linkedin.com/in/jacobpbrooker"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">jacobpbrooker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This static page has been created to showcase various projects and design works to accent and enhance my resume and cover letter. I hope you enjoy my work.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
