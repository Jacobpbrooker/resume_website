<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Binary Search Tree in C | Jacob Brooker - Project Showcase</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Binary Search Tree in C" />
<meta name="author" content="Jacob Brooker" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this section I will discuss the creation of my Binary Search Tree (BST) Algorithm. A BST is best used to store data in organized way that allows for relatively quick search, insert, and deletes. Most commonly, BST can be used as quick index lookup tables. One of the major benefits of the BST is the algorithmic complexity Big O notation of the various functions. As the BST is organized, the search function maintains an O(height) linear complexity while the delete and insert functions generally maintain a O(n complexity)." />
<meta property="og:description" content="In this section I will discuss the creation of my Binary Search Tree (BST) Algorithm. A BST is best used to store data in organized way that allows for relatively quick search, insert, and deletes. Most commonly, BST can be used as quick index lookup tables. One of the major benefits of the BST is the algorithmic complexity Big O notation of the various functions. As the BST is organized, the search function maintains an O(height) linear complexity while the delete and insert functions generally maintain a O(n complexity)." />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2021/10/05/binary-tree.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2021/10/05/binary-tree.html" />
<meta property="og:site_name" content="Jacob Brooker - Project Showcase" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-10-05T15:43:03-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Binary Search Tree in C" />
<script type="application/ld+json">
{"headline":"Binary Search Tree in C","dateModified":"2021-10-05T15:43:03-04:00","datePublished":"2021-10-05T15:43:03-04:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2021/10/05/binary-tree.html"},"author":{"@type":"Person","name":"Jacob Brooker"},"description":"In this section I will discuss the creation of my Binary Search Tree (BST) Algorithm. A BST is best used to store data in organized way that allows for relatively quick search, insert, and deletes. Most commonly, BST can be used as quick index lookup tables. One of the major benefits of the BST is the algorithmic complexity Big O notation of the various functions. As the BST is organized, the search function maintains an O(height) linear complexity while the delete and insert functions generally maintain a O(n complexity).","url":"http://localhost:4000/jekyll/update/2021/10/05/binary-tree.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Jacob Brooker - Project Showcase" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Jacob Brooker - Project Showcase</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/resume/">Resume</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Binary Search Tree in C</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-10-05T15:43:03-04:00" itemprop="datePublished">Oct 5, 2021
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Jacob Brooker</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div>
	<p description="About Binary Trees">
	In this section I will discuss the creation of my Binary Search Tree (BST) Algorithm. A BST is best used to store data in organized way that allows for relatively quick search, insert, and deletes. Most commonly, BST can be used as quick index lookup tables.
	<br /><br />
	One of the major benefits of the BST is the algorithmic complexity Big O notation of the various functions. As the BST is organized, the search function maintains an O(height) linear complexity while the delete and insert functions generally maintain a O(n complexity).
	</p>
</div>

<h3><br />Application Decomposition and Explanation</h3>

<p>The appplication uses one struct as both the container for the data and the pointers to the child nodes.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">treeNode</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">treeNode</span><span class="o">*</span> <span class="n">pLeft</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">treeNode</span><span class="o">*</span> <span class="n">pRight</span><span class="p">;</span>
<span class="p">}</span><span class="n">TREENODE</span><span class="p">,</span> <span class="o">*</span><span class="n">PTREENODE</span><span class="p">;</span>
</code></pre></div></div>

<p>The first step in the application building the binary tree is to create a node. All nodes created by this function store a randomly generated int as the data, and set the children nodes to default.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PTREENODE</span> <span class="nf">createNewNode</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PTREENODE</span> <span class="n">newNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTREENODE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TREENODE</span><span class="p">));</span>			<span class="c1">// create a new node and malloc</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newNode</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to malloc newNode</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">newNode</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>										<span class="c1">// random number generator of data</span>
	<span class="n">newNode</span><span class="o">-&gt;</span><span class="n">pLeft</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>												<span class="c1">// set left</span>
	<span class="n">newNode</span><span class="o">-&gt;</span><span class="n">pRight</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>												<span class="c1">// set right to null</span>
	<span class="k">return</span> <span class="n">newNode</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Within the main function, I call the create node function to make the root of the tree. To make the code more readable, I typedef a pointer to make the custom struct naed “root”.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">treeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>

<span class="n">root</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">createNewNode</span><span class="p">();</span>	
</code></pre></div></div>
<p>To create the binary tree, we insert each node into the tree. To accomplish this, I decided to write the insert function through recursive calls to the left or right children.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">PTREENODE</span> <span class="n">currentNode</span><span class="p">,</span> <span class="n">PTREENODE</span> <span class="n">newNode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newNode</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">currentNode</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>								<span class="c1">// is newNode data less than current node?</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">currentNode</span><span class="o">-&gt;</span><span class="n">pLeft</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>									<span class="c1">// is the pointer to left of node empty?</span>
			<span class="n">currentNode</span><span class="o">-&gt;</span><span class="n">pLeft</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>								<span class="c1">// if it is then attach newNode to left of currentNode</span>
		<span class="k">else</span>
			<span class="n">insert</span><span class="p">(</span><span class="n">currentNode</span><span class="o">-&gt;</span><span class="n">pLeft</span><span class="p">,</span> <span class="n">newNode</span><span class="p">);</span>						<span class="c1">// else call again with node to the left</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">newNode</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">currentNode</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>							<span class="c1">// is newNode data greater than current node?</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">currentNode</span><span class="o">-&gt;</span><span class="n">pRight</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>								<span class="c1">// is the pointer to right of node empty?</span>
			<span class="n">currentNode</span><span class="o">-&gt;</span><span class="n">pRight</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>								<span class="c1">// attach newNode to right of node</span>
		<span class="k">else</span>
			<span class="n">insert</span><span class="p">(</span><span class="n">currentNode</span><span class="o">-&gt;</span><span class="n">pRight</span><span class="p">,</span> <span class="n">newNode</span><span class="p">);</span>						<span class="c1">// else call again with node to the right</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Now I want to explain three functions I created with the Binary Tree. The first is the search for node function. Passed into this function is the pointer to the root of the tree, and the integer we are searching for. To create a more readable solution, the function is written as a recusive algorithm that will follow a path by comparing the search integer to the integer in the current node. If the search node is less than the node integer, we recursively call with the left child node. If the search node is greater than the current node integer, we recusrively call the search function with the right child node.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PTREENODE</span> <span class="nf">search</span><span class="p">(</span><span class="n">PTREENODE</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">searchNode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> 
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>													<span class="c1">// exit condition, search not found</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">searchNode</span> <span class="o">==</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>										<span class="c1">// search found, returning node</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Node searched %d, Node returned - "</span><span class="p">,</span> <span class="n">searchNode</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">node</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">searchNode</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>									<span class="c1">// search int is lower than current node - move left</span>
		<span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">pLeft</span><span class="p">,</span> <span class="n">searchNode</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">searchNode</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>									<span class="c1">// search int is higher than current node - move right</span>
		<span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">pRight</span><span class="p">,</span> <span class="n">searchNode</span><span class="p">);</span>

	
<span class="p">}</span>
</code></pre></div></div>
<p>Next, I will demonstrate my function to count the number of nodes on the binary search tree. This function once again works on recursion. First we will follow the tree through the left (less than parent) child nodes. As we work our way back up, the right (greater than parent) child nodes are counted. Finally, we add one to account for the root of the tree.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">PTREENODE</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>													<span class="c1">// if node is NULL then there is no list and return 0</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
	<span class="k">return</span><span class="p">(</span><span class="n">countNodes</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">pLeft</span><span class="p">)</span> <span class="o">+</span> <span class="n">countNodes</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">pRight</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>		<span class="c1">// recursively count the number of nodes to the left and to the right</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Lastly, I would like to demonstrate the funciton to calculate the height of the binary search tree. This is an important function as the complexity of the BST can be determined by the height of the tree. This function works by recusively calculating the height of the left pathways, then recursively calculating the height of the right pathways. It then determines which path is the longest, adds one to account for root node, and then returns the greater of the two.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">treeHeight</span><span class="p">(</span><span class="n">PTREENODE</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">leftHeight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">rightHeight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
	<span class="kt">int</span> <span class="n">returnHeight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> 
		<span class="k">return</span> <span class="n">returnHeight</span><span class="p">;</span>											<span class="c1">// no list, return 0</span>
	
	<span class="n">leftHeight</span> <span class="o">=</span> <span class="n">treeHeight</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">pLeft</span><span class="p">);</span>								<span class="c1">// recursive call again left</span>

	<span class="n">rightHeight</span> <span class="o">=</span> <span class="n">treeHeight</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">pRight</span><span class="p">);</span>								<span class="c1">// recursive call again right</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">leftHeight</span> <span class="o">&gt;</span> <span class="n">rightHeight</span><span class="p">)</span>										<span class="c1">// check which height is longer, left or right</span>
		<span class="n">returnHeight</span> <span class="o">=</span> <span class="n">leftHeight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>									<span class="c1">// return height of left, the +1 is to account for the head</span>
	<span class="k">else</span>
		<span class="n">returnHeight</span> <span class="o">=</span> <span class="n">rightHeight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>									<span class="c1">// return height of right the +1 is to account for the head</span>
	
	<span class="k">return</span> <span class="n">returnHeight</span><span class="p">;</span>												<span class="c1">// return the height of the tree</span>
<span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h3>Running the Application</h3>
<p>First, the application will conduct an inorder traversal of the tree. Next, the application calls the search function and returns the tree node. It then calculates the height of the tree, and the total number of nodes inside the tree.
 <br /><br />
<img src="/assets/img/programs/bst.png" height="300px" />
<br /><br /></p>
<hr />

<h3><a href="https://github.com/Jacobpbrooker/binary_tree">You can find the GitHub Repo here!</a></h3>
<p><br />
If you have any questions at all, please do not hesitate to reach out. Thanks for reading!</p>

  </div><a class="u-url" href="/jekyll/update/2021/10/05/binary-tree.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Jacob Brooker - Project Showcase</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Jacob Brooker</li><li><a class="u-email" href="mailto:jacobpbrooker@gmail.com">jacobpbrooker@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Jacobpbrooker"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Jacobpbrooker</span></a></li><li><a href="https://www.linkedin.com/in/jacobpbrooker"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">jacobpbrooker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This static page has been created to showcase various projects and design works to accent and enhance my resume and cover letter. I hope you enjoy my work.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
